////////////////////////////////////////////////////////////////////////////////
// Filename: List.inl
// Author:   Tobias Savinainen
// Year:     2013
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Header files
////////////////////////////////////////////////////////////////////////////////
#include "List.hpp"

namespace sfx
{

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::addBack(const T& element)
{
    m_list.push_back(element);
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::addFront(const T& element)
{
    m_list.push_front(element);
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> std::size_t List<T>::getSize() const
{
    return m_list.size();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> T& List<T>::front()
{
    return m_list.front();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> const T& List<T>::front() const
{
    return m_list.front();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> T& List<T>::back()
{
    return m_list.back();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T>const T& List<T>::back() const
{
    return m_list.back();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> typename List<T>::iterator List<T>::begin()
{
    return m_list.begin();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> typename List<T>::const_iterator List<T>::begin() const
{
    return m_list.begin();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> typename List<T>::iterator List<T>::end()
{
    return m_list.end();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> typename List<T>::const_iterator List<T>::end() const
{
    return m_list.end();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> bool List<T>::isEmpty() const
{
    return m_list.empty();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> bool List<T>::hasValue() const
{
    return !m_list.empty();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::clear()
{
    m_list.clear();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> typename List<T>::iterator List<T>::remove(iterator it)
{
    return m_list.erase(it);
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::remove(const T& element)
{
    for (auto& it = m_list.begin(); it != m_list.end();)
    {
        if (*it == element)
            it = m_list.erase(it);
        else
            ++it;
    }
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::removeBack()
{
    if (m_list.empty())
        return;

    m_list.pop_back();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::removeFront()
{
    if (m_list.empty())
        return;

    m_list.pop_front();
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::insert(iterator it, const T& element)
{
    m_list.insert(it, element);
}

////////////////////////////////////////////////////////////////////////////////
template<typename T> void List<T>::insert(const_iterator it, const T& element)
{
    m_list.insert(it, element);
}

} // namespace sfx